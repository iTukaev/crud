package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

type StructInfo struct {
	Name   string
	Target *ast.StructType
}

func main() {
	if len(os.Args) != 2 {
		log.Fatalln("Invalid arguments: expected \"chaingen file_name.go\"")
	}
	fSet := token.NewFileSet()
	node, err := parser.ParseFile(fSet, os.Args[1], nil, parser.ParseComments)
	if err != nil {
		log.Fatalln("Parse file:", err)
	}
	allStructs, imports := parseFile(node)
	_ = genChain(allStructs, imports, node.Name.Name)

}

func parseFile(node *ast.File) ([]*StructInfo, map[string]string) {
	allStructs := make([]*StructInfo, 0)
	imports := make(map[string]string, 0)
	for _, f := range node.Decls {
		genD, ok := f.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range genD.Specs {
			currType := &ast.TypeSpec{}
			switch val := spec.(type) {
			case *ast.TypeSpec:
				currType = val
			case *ast.ImportSpec:
				key, imp := parseImport(val)
				imports[key] = imp
				continue
			default:
				continue
			}
			currStruct, ok := currType.Type.(*ast.StructType)
			if !ok {
				continue
			}
			allStructs = append(allStructs, &StructInfo{
				Name:   currType.Name.Name,
				Target: currStruct,
			})
		}
	}
	return allStructs, imports
}

func genChain(allStructs []*StructInfo, imports map[string]string, packageName string) error {
	for _, st := range allStructs {
		toImport := make(map[string]bool, 0)
		buf := bytes.NewBufferString("")
		next := fmt.Sprintf("func New%s() *%[1]s {", st.Name)
		_, _ = fmt.Fprintln(buf, next)
		next = fmt.Sprintf("\treturn &%s{}", st.Name)
		_, _ = fmt.Fprintln(buf, next)
		_, _ = fmt.Fprintln(buf, "}")

		stName := strings.ToLower(string(st.Name[0]))
		for _, f := range st.Target.Fields.List {
			if len(f.Names) == 0 {
				continue
			}

			var fType string
			switch val := f.Type.(type) {
			case *ast.SelectorExpr:
				fType = fmt.Sprintf("%s.%s", val.X, val.Sel)
				toImport[fmt.Sprintf("%s", val.X)] = true
			case *ast.StarExpr:
				switch val := val.X.(type) {
				case *ast.SelectorExpr:
					fType = fmt.Sprintf("*%s.%s", val.X, val.Sel)
					toImport[fmt.Sprintf("%s", val.X)] = true
				case *ast.Ident:
					fType = fmt.Sprintf("*%s", val)
				}
			default:
				fType = fmt.Sprintf("%s", val)
			}

			fName := f.Names[0].Name
			_, _ = fmt.Fprintln(buf)
			_, _ = fmt.Fprintf(buf, "func (%s *%s) %sSet(%[3]s %s) *%[2]s {\n", stName, st.Name, fName, fType)
			_, _ = fmt.Fprintf(buf, "\t%s.%s = %[2]s\n", stName, fName)
			_, _ = fmt.Fprintf(buf, "\treturn %s\n", stName)
			_, _ = fmt.Fprintln(buf, "}")
		}

		name := fmt.Sprintf("%s_chain.go", strings.ToLower(st.Name))
		file, err := os.Create(name)
		if err != nil {
			return err
		}
		_, _ = fmt.Fprintln(file, "// Code generated by chaingen. DO NOT EDIT.")
		_, _ = fmt.Fprintln(file)
		_, _ = fmt.Fprintln(file, "package", packageName)
		_, _ = fmt.Fprintln(file)

		if len(toImport) != 0 {
			_, _ = fmt.Fprintln(file, "import (")
			for key := range toImport {
				_, _ = fmt.Fprintf(file, "\t%s\n", imports[key])
			}
			_, _ = fmt.Fprintln(file, ")")
			_, _ = fmt.Fprintln(file)
		}
		_, _ = fmt.Fprint(file, buf)
		if err = file.Close(); err != nil {
			return nil
		}
	}

	return nil
}

func parseImport(val *ast.ImportSpec) (string, string) {
	if val.Name != nil {
		return val.Name.Name, fmt.Sprintf("%s %s", val.Name.Name, val.Path.Value)
	} else {
		names := strings.Split(strings.ReplaceAll(val.Path.Value, "\"", ""), "/")
		return names[len(names)-1], val.Path.Value
	}
}
